---
title: "What Building malloc() Taught About Memory"
date: "2024-01-10"
description: "Building a dynamic memory allocator from scratch in C reveals truths about systems programming that no textbook can convey."
image: "/images/blog/blog-malloc.png"
tags: ["technical", "C", "Systems Programming", "Memory Management", "Low-Level"]
---

# What Building malloc() Taught About Memory

Every developer uses `malloc()` and `free()`. Few understand what happens beneath the abstraction. For Fardin Iqbal, building his own implementation changed how he thinks about memory forever.

## The Challenge

The assignment was deceptively simple: implement `malloc()`, `free()`, and `realloc()` for x86-64. The constraints:

- No external libraries
- Must handle arbitrary allocation sizes
- Must be thread-safe (bonus)
- Must be *fast*

What appears simple becomes complex once the implementation begins.

## How Memory Actually Works

When a program starts, the operating system provides a heap—a contiguous region of memory. The allocator's responsibility is to carve this region efficiently.

```
Heap Layout:
┌─────────────────────────────────────────────┐
│ Header │ Block 1 │ Header │ Block 2 │ ...   │
└─────────────────────────────────────────────┘
         ↑                   ↑
         Allocated           Free
```

Each block requires a header storing its size and status. The challenge lies in minimizing overhead while maximizing speed.

## Strategy: Segregated Free Lists

Rather than maintaining one large free list, Fardin's implementation uses multiple lists based on size classes:

```c
// Size classes: 32, 64, 128, 256, 512, 1024, 2048, 4096+
static block_t *free_lists[NUM_SIZE_CLASSES];

void *sf_malloc(size_t size) {
    int class = get_size_class(size);
    block_t *block = find_fit(class);

    if (!block) {
        block = request_more_heap();
    }

    return split_and_allocate(block, size);
}
```

This provides O(1) allocation for common sizes—a significant performance advantage.

## The Coalescing Problem

When a block is freed, it must be merged with adjacent free blocks. Otherwise, fragmentation occurs—numerous small free blocks that cannot satisfy large requests.

```c
void sf_free(void *ptr) {
    block_t *block = get_block(ptr);

    // Check previous block
    if (prev_is_free(block)) {
        block = coalesce_with_prev(block);
    }

    // Check next block
    if (next_is_free(block)) {
        block = coalesce_with_next(block);
    }

    add_to_free_list(block);
}
```

Coalescing is essential for long-running programs that allocate and free memory repeatedly.

## Security: Header Obfuscation

A vulnerability exists: attackers can overflow a buffer and corrupt adjacent block headers. The solution: XOR headers with a magic value.

```c
#define MAGIC 0xDEADBEEF

size_t encode_header(size_t header) {
    return header ^ MAGIC;
}

size_t decode_header(size_t encoded) {
    return encoded ^ MAGIC;
}
```

This approach is not bulletproof, but it catches most corruption attempts and makes exploitation significantly more difficult.

## Performance Results

After optimization, the allocator achieved:

- **malloc**: ~50 cycles for cached sizes
- **free**: ~30 cycles with coalescing
- **Memory overhead**: 8 bytes per block
- **Fragmentation**: <5% on typical workloads

These numbers compete with production allocators for common use cases.

## Principles Learned

**Every byte counts.** Headers consume usable memory. The tradeoff between metadata and payload is constant.

**Cache locality matters.** Keeping metadata close to data improves performance dramatically.

**Trade-offs are everywhere.** Speed versus memory versus complexity—every decision involves sacrifice.

**Debugging is difficult.** Printf does not work reliably when the heap is corrupted. Alternative debugging strategies become necessary.

## The Broader Perspective

Understanding memory allocation changes how one writes code:

- One thinks twice before allocating in hot paths
- One understands why languages implement garbage collectors
- One appreciates the complexity hidden behind simple APIs

For those seeking genuine understanding of systems programming, building something that manages memory is invaluable. The lessons become embodied rather than merely known.

---

*The full implementation is available on [GitHub](https://github.com/FardinIqbal/dynamic-memory-allocator). Fardin built this as part of his systems programming coursework at Stony Brook University.*
